<script>
	pre (function () {
		var pages =	files ('.ejs') (tags_src)
						.map (function (tag_path) {
							var tag_relative_path = tag_path .slice (tags_src .length + 1);
							var tag_name =	tag_relative_path
												.split ('/') .join ('-')
												.split ('.') [0];
							if (tag_name .startsWith ('page-'))
								return tag_name .slice ('page-' .length)
						})
						.filter (R .identity);
		scripts .unshift (
			`var all_pages = ${JSON .stringify (pages)};`
		);
	})
</script>
<script>
	window .page_components = R .pipe (
		R .map (
			R .juxt ([R .identity, just_call (stream)])
		),
		R .fromPairs
	) (all_pages);
	window .page_cache = stream ({});
	window .page_name =	function (path) {
							if (path === '' || path === '#')
								path = routes .default
							return path .slice (path .indexOf ('#') + 1, path .indexOf ('/#') === -1 ? undefined : path .indexOf ('/#'))
						}
	window .page_exists =	function (page_name) {
								return all_pages .indexOf (page_name .split ('/') .join ('-')) !== -1;
							};


	var tag_label =	function (page_name) {
						return 'page-' + replace_all ('/', '-') (trim_trailing_slash (page_name));
					};
						var trim_trailing_slash =	function (path) {
														if (path [path .length - 1] === '/')
															return path .slice (0, -1);
														else
															return path;
													};
	var page_params =	function (path) {
							return (path .indexOf ('/#') !== -1 ? path .slice (path .indexOf ('/#') + 2) .split ('/') : []);
						};
	var page_label = 	function (path) {
							var params = page_params (path);
							return '#' + page_name (path) + (params .length ? '/#' + params .join ('/') : '')
						};
	var nav_of = R .cond ([
		[R .identity, R .prop ('nav')]])
		
		
	var extension = interaction (transition (function (intent, license) {
		if (intent [0] === 'nav') {
			var nav_data = intent [1];
			var last_state = intent [2];
			
			return function (tenure) {
				var time = new Date ()
				
				var curr = page_cache () [nav_data .id];
				if (curr) {
					curr = retaining (nav_data) (Object .getPrototypeOf (curr))
				}
				else {
					var _tag_label = tag_label (nav_data .name);
					curr = 	retaining (nav_data) (
								riot .mount (
									document .createElement (_tag_label),
									_tag_label,
									having (nav_data .params) ({
										parent: self
									})) [0]);
					nav_of (curr) .state
						.thru (dropRepeats)
						.thru (filter, R .identity)
						.thru (tap, 
							R .converge (extension .intent,
								[R .juxt ([
									R .always ('nav'),
									R .converge (R .mergeAll, 
										[R .juxt ([
											R .pipe (
												R .converge (routing, [R .always (curr .name), R .prop (0)]),
												R .applySpec ({
													name: page_name,
													params: page_params,
													id: page_label
												})),
											R .pipe (
												R .prop (0),
												R .applySpec ({
													intent: R .identity
												})),
											R .pipe (
												R .prop (1),
												R .applySpec ({
													args: R .identity
												}))
										])]),
									just_call (extension .state)
								])]
							))
							
					//HACK: riot data-is bug, not firing mount
					if (self .isMounted) {
						self .renders .push ('now');
						self .update ();
						self .renders .pop ();
					}
				}
				
				if (nav_of (curr)) {
					nav_of (curr) .intent (['prepare', curr .intent, curr .args]);
				}
				if (! license ()/* || curr .id === license () [1] .id*/) {
					if (last_state !== curr) {
						var _time = new Date ()
						
						if ('intent' in curr)
							replace_hash (curr .id);
						else
							silent_replace_hash (curr .id);
						
						self .root .insertBefore (curr .root, self .root .firstElementChild);
						if (last_state) {
							self .root .removeChild (last_state .root);
						}
						
						log ('mounted page time ' + (new Date () - _time) + 'ms', curr);	
					}
					var last_loaded = curr;
				}
				else {
					var last_loaded = last_state;
				}
				
				if (last_state) {
					nav_of (last_state) .intent (['reset']);
				}
	
				log ('process page time ' + (new Date () - time) + 'ms', curr);	

				tenure (last_loaded);
				tenure .end (true);
				if (license ())
					extension .intent (license ());
			}
		}
		else {
			return decline_ (intent);
		}
	}));
	
	
	var replace_hash = function (x) {
		history .pushState (null, null, x);
	};
	var silent_replace_hash = function (x) {
		history .replaceState (null, null, x);
	};
	
	from (function (nav) {
		window .addEventListener ('hashchange', function () {
			nav (window .location .hash)
		});
		if (page_exists (page_name (window .location .hash))) {
			nav (window .location .hash)
		}
		else {
			window .location .hash = routes .default;
		}
	})
	.thru (map, R .applySpec ({
		name: page_name,
		params: page_params,
		id: page_label
	}))
	.thru (filter, R .pipe (R .prop ('name'), page_exists))
	.thru (tap,
		R .converge (extension .intent,
			[R .juxt (
				[R .always ('nav'), R .identity, just_call (extension .state)])
			])
	);


	extension .state
		.thru (filter, R .identity)
		.thru (dropRepeats)
		.thru (tap, function (page) {
			if (! page_cache () [page .id] && ! page .temp)
				page_cache (
					R .assoc (page .id, page) (page_cache ()))
		});
		
	window ._interaction = interaction_key_sum (
		interaction_product ({
			_: extension
		}),
		interaction_flatten (page_cache .thru (map, R .map (R .prop ('interaction'))) .thru (map, interaction_product))
	)
</script>
<script>
	from (function (widths) {
		widths (window .innerWidth);
		window .addEventListener ('resize', function () {
			widths (window .innerWidth);
		});
	})
	.thru (dropRepeats)
	.thru (map, function (width) {
		return { width: width, height: window .innerHeight };
	})
	.thru (tap, function (size) {
		self .root .style .setProperty ('width', size .width + 'px', 'important');
		self .root .style .setProperty ('height', size .height + 'px', 'important');
	});
</script>